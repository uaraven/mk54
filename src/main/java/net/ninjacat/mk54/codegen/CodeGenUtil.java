package net.ninjacat.mk54.codegen;

import net.ninjacat.mk54.exceptions.InvalidJumpTargetException;
import org.objectweb.asm.MethodVisitor;

import static org.objectweb.asm.Opcodes.*;


/**
 * Utility methods for code generation.
 * <p>
 * Code generated by these methods does not map to any of MK operations
 */
final class CodeGenUtil {

    static final String REGISTER_X = "x";
    static final String REGISTER_X1 = "x1";
    static final String REGISTER_Z = "z";
    static final String REGISTER_T = "t";
    static final String REGISTER_Y = "y";
    static final String REGISTER_X_MANTISSA = "xMantissa";
    static final String REGISTER_X_EXPONENT = "xExponent";
    static final String MEMORY = "memory";
    static final String RESET_X = "resetX";

    static final String ENTRY_MODE = "entryMode";
    static final String DECIMAL_FACTOR = "decimalFactor";
    static final String CLASS_NAME = "net/ninjacat/mk54/Mk54";
    static final String CLASS_DESCRIPTOR = "L" + CLASS_NAME + ";";

    static final String JAVA_LANG_MATH = "java/lang/Math";

    private CodeGenUtil() {
    }


    /**
     * Parses binary-decimal MK address.
     *
     * @param addr Address written in MK format
     * @return integer address
     */
    static int parseAddress(final String addr) {
        if (addr.length() != 2) {
            throw new InvalidJumpTargetException(addr);
        }
        final int addr1 = Integer.parseInt(addr.substring(0, 1), 16);
        final int addr2 = Integer.parseInt(addr.substring(1, 2), 16);
        return addr1 * 10 + addr2;
    }

    /**
     * Moves stack down from T to Z and Z  to Y. This must be executed for every operation which
     * combines Y and X and puts result to X
     *
     * @param mv      Generated method visitor
     * @param context Code generation context
     */
    static void stackDown(final MethodVisitor mv, final CodeGenContext context) {
        mv.visitVarInsn(ALOAD, 0);
        mv.visitVarInsn(ALOAD, 0);
        mv.visitFieldInsn(GETFIELD, CLASS_NAME, REGISTER_Z, "D");
        mv.visitFieldInsn(PUTFIELD, CLASS_NAME, REGISTER_Y, "D");

        mv.visitVarInsn(ALOAD, 0);
        mv.visitVarInsn(ALOAD, 0);
        mv.visitFieldInsn(GETFIELD, CLASS_NAME, REGISTER_T, "D");
        mv.visitFieldInsn(PUTFIELD, CLASS_NAME, REGISTER_Z, "D");
    }

    /**
     * Saves X to X1
     *
     * @param mv      Generated method visitor
     * @param context Code generation context
     */
    static void saveX(final MethodVisitor mv, final CodeGenContext context) {
        mv.visitVarInsn(ALOAD, 0);
        mv.visitVarInsn(ALOAD, 0);
        mv.visitFieldInsn(GETFIELD, CLASS_NAME, REGISTER_X, "D");
        mv.visitFieldInsn(PUTFIELD, CLASS_NAME, REGISTER_X1, "D");
    }

    /**
     * Helper method called on all operations. Sets resetX flag to true
     *
     * @param mv      Generated method visitor
     * @param context Code generation context
     */
    static void prepareXForReset(final MethodVisitor mv, final CodeGenContext context) {
        mv.visitVarInsn(ALOAD, 0);
        mv.visitInsn(ICONST_1);
        mv.visitFieldInsn(PUTFIELD, CLASS_NAME, RESET_X, "Z");

        forcePushStack(mv, context);
    }

    /**
     * Sets {@link net.ninjacat.mk54.Mk54#pushStack} flag, forcing pushing current register X up the stack
     * when next digit or F Pi operation is processed
     *
     * @param mv      Generated method visitor
     * @param context Code generation context
     */

    static void forcePushStack(final MethodVisitor mv, final CodeGenContext context) {
        mv.visitVarInsn(ALOAD, 0);
        mv.visitInsn(ICONST_1);
        mv.visitFieldInsn(PUTFIELD, CLASS_NAME, "pushStack", "Z");
    }

    /**
     * Clears {@link net.ninjacat.mk54.Mk54#pushStack} flag, preventing pushing current register X up the stack
     * when next digit or F Pi operation is processed
     *
     * @param mv      Generated method visitor
     * @param context Code generation context
     */
    static void delayPushStack(final MethodVisitor mv, final CodeGenContext context) {
        mv.visitVarInsn(ALOAD, 0);
        mv.visitInsn(ICONST_0);
        mv.visitFieldInsn(PUTFIELD, CLASS_NAME, "pushStack", "Z");
    }


    /**
     * Switches digit entry mode to exponent
     *
     * @param mv      Generated method visitor
     * @param context Code generation context
     */
    static void startExponent(final MethodVisitor mv, final CodeGenContext context) {
        mv.visitVarInsn(ALOAD, 0);
        mv.visitInsn(ICONST_1);
        mv.visitFieldInsn(PUTFIELD, CLASS_NAME, ENTRY_MODE, "I");
    }

    /**
     * Logic for modifying registers during indirect operations
     *
     * @param register memory register number
     * @param mv       Generated method visitor
     */
    static void modifyRegisterForIndirect(final int register, final MethodVisitor mv) {
        if (register >= 0 && register <= 3) {
            mv.visitVarInsn(ALOAD, 0);
            mv.visitFieldInsn(GETFIELD, CLASS_NAME, MEMORY, "[D");
            mv.visitIntInsn(BIPUSH, register);
            mv.visitInsn(DUP2);
            mv.visitInsn(DALOAD);
            mv.visitInsn(DCONST_1);
            mv.visitInsn(DSUB);
            mv.visitInsn(DASTORE);
        } else if (register >= 4 && register <= 6) {
            mv.visitVarInsn(ALOAD, 0);
            mv.visitFieldInsn(GETFIELD, CLASS_NAME, MEMORY, "[D");
            mv.visitIntInsn(BIPUSH, register);
            mv.visitInsn(DUP2);
            mv.visitInsn(DALOAD);
            mv.visitInsn(DCONST_1);
            mv.visitInsn(DADD);
            mv.visitInsn(DASTORE);
        }
    }
}
